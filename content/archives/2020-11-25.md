---
title: OAM & KubeVela 学习笔记
date: 2020-11-25
tags: 
---

# OAM

OAM，Open Application Model，开放应用模型。
https://github.com/oam-dev/spec

阿里云与微软联合推出的开源项目。

## 为什么需要 OAM

在 Kubernetes 坏境中，应用发布可能不只需要 Deployment，可能还需要 Service、Ingress、Configmap。
但这些 Kubernetes 中的资源，实际上只是应用中的不同组成部分，并不能代表一个应用的全部。

现阶段，较为流行的 Helm、Kustomize 其实也都是对应用的抽象，而不是约束。
抽象，很可能只是一个变量而已。

<!--more-->

## OAM 定义

OAM 的核心，以应用为中心，提供一个专注于应用管理的、标准的、高度一致的模型。

## OAM 组成

### 应用组件 components

应用层抽象。
OAM 对用户暴露出自己定义的应用层抽象。

实际上是帮助定义 Deployment、StatefulSet 这样的 Workload 的。
暴露给用户，让用户去定义这些应用的语义。

主要是用来声明应用的属性：
- 元数据 metadata
- 工作负载类型 workloadType
- 工作负载定义
- 资源需求
- 参数 parameters

应用组件既包括应用服务本身，也可以包括应用运行所依赖的服务。
开发者可以把他们写的代码打包成一个应用组件，然后编写配置文件来描述该组件与其他服务之间的关系。

应用组件的概念，让平台架构师能够将应用分解成一个个可被复用的模块。

这种模块化封装应用组成部分的思想，代表了一种构建安全、高可扩展性应用的最佳实践：
它通过一个完全分布式的架构模型，实现了应用组件描述和实现的解耦。

```
apiVersion: core.oam.dev/v1alpha1
kind: ComponentSchematic
metadata:
  name: alpine-forever-v1
spec:
  workloadType: core.oam.dev/v1alpha1.SingletonServer
  containers:
    - name: runner
      image: technosophos/alpine-forever:latest
      env:
        - name: FOO
          value: bar
          fromParam: message
        - name: UNUSED
          value: "1234"
          fromParam: unused_integer
  parameters:
    - name: message
      type: string
      required: false
    - name: unused_integer
      type: number
      required: false
      default: 5678
```

![image](https://70data.oss-cn-beijing.aliyuncs.com/note/20201123190518.png)

### 应用特征 traits

运维侧的概念，比如 Ingress 规则、扩容策略，发布策略。

1. OAM 对 traits 的实现没有任何限制，traits 一般作用于应用的安装和升级时。
2. traits 应该按照定义的顺序施加到组件上。
3. traits 需要关联 components。
4. 应用部署只有当所有组件和其 traits 都正常运行起来才能标记为部署成功。
5. OAM 平台应该支持组件施加多个 traits，这些 traits 可能是相同的类型。

- 元数据 metadata
- 属性 properties

```
apiVersion: core.oam.dev/v1alpha1
kind: ApplicationConfiguration
metadata:
  name: first-app
spec:
  components:
  - componentName: nginx-component
    instanceName: first-app-nginx
    parameterValues:
      - name: poet
        value: Eliot
      - name: poem
        value: The Wasteland
    traits:
      - name: ingress
        properties:
          hostname: example.com
          path: /
          servicePort: 80
```

目前 traits 主要分为三类：
- core traits，`core.oam.dev`，必要的运维特征
- standard traits，`standard.oam.dev`，常用的运维特征
- extension traits，自定义运维特征

##### 解决了什么问题

同样是 Ingress，它在公有云和私有化部署的实现可能是完全不同的。
公有云一般是 SLB 这样的云服务。
私有化部署可能是一个专门的硬件，也可能使一个高可用的服务。

这意味着针对这两个环境的 Ingress 运维工作，将会有天壤之别。
但与此同时，无论是在哪个环境里，这个 Ingress 规则对于应用开发人员来说，可能是完全相同的。

应用特征的设计，让这种关注点分离成为可能：
只要这两个环境在 OAM 模型下提供了对 Ingress 这个应用运维特征的实现，那么这个应用就可以使用统一的 Ingress 规则描述，无差别的在这两个地方运行起来。

### 应用配置 ApplicationConfiguration

为了让这些应用组件描述变成一个真正运行起来的应用，应用运维人员会通过一个专门的、包含了所有应用组件信息的部署配置文件来实例化这个待运行的应用。

这个配置文件本身也是 OAM 规范中的一个声明式 API，用来让应用运维人员能够根据开发者或者平台提交的应用描述，实例化出对应的、真正运行起来的应用。

##### 应用边界 applicationScopes

通过提供表示公共行为 and/or 依赖关系的应用边界来逻辑地将组件分组。

作用域不是互斥的，一个给定的组件可以同时属于多个应用程序作用域实例。

![image](https://70data.oss-cn-beijing.aliyuncs.com/note/20201123173320.jpg)

应用配置组成：
- 元数据 metadata
- 类型 type
- 参数 parameterValues

1. 描述该组件实例的公共行为和元数据。
2. 一个组件可以同时部署到多个不同类型的应用边界中。
3. 应用边界类型可以决定组件是否可以部署到多个相同的应用边界类型实例。
4. 应用边界可以用于不同组件分组以及不同 infra 能力之间的连接机制。

应用边界类型目前有两种：
- 核心应用边界类型 `core.oam.dev`
- 扩展应用边界类型

核心应用边界类型 `core.oam.dev` 目前支持两种：
- NetworkScope
- HealthScope

```
apiVersion: core.oam.dev/v1alpha1
kind: ApplicationConfiguration
metadata:
  name: first-app
spec:
  components:
    - name: helloworld-python-v1
      instanceName: first-app-helloworld-python-v1
      parameterValues:
        - name: target
          value: Rudr
        - name: port
          value: "9999"
      traits:
        - name: ingress
        properties:
          hostname: example.com
          path: /
          servicePort: 9999
      applicationScopes:
        - my-health-scope
```

```
apiVersion: core.oam.dev/v1alpha1
kind: ApplicationConfiguration
metadata:
  name: my-health-scope
spec:
  scopes:
    - name: health
      type: core.oam.dev/v1alpha1.HealthScope
      properties:
        - name: probe-method
          value: "kube-get"
        - name: probe-endpoint
          value: ".status"
        - name: probe-timeout
          value: 30
        - name: probe-interval
          value: 60
        - name: failure-rate-threshold
          value: 0
        - name: healthy-rate-threshold
          value: 100.0
        - name: healthThresholdPercentage
          value: 100.0
```

![image](https://70data.oss-cn-beijing.aliyuncs.com/note/20201218020653.png)

## OAM 特性

与 PaaS 应用模型相比，OAM 有很多独有的特点。

### 关注点分离

开发者关注应用本身，运维人员关注模块化运维能力。

应用管理变得更轻松、应用交付变得更可控。

### 平台无关性

OAM 与 Kubernetes 并没有强耦合。

实际上，OAM 可以实现到任意平台或运行环境之上，这当然也包括边缘计算与物联网的场景。

Kubernetes 在很多运行环境中可能并不是最好的选择，或者是像 Serverless 这类用户并不需要关心基础设施复杂性的运行环境。
在这些场景下，OAM 都可以提供完全一致的应用管理体验。

### 可扩展性

OAM 不像 PaaS 那样自成封闭体系，也不会通过某种独有的应用管理环境来屏蔽掉底层平台的特点。

OAM 使平台层可以通过应用特征系统(trait system)来体现平台的特性和差异性。
只要不同的平台都能够提供应用所需要的某些应用特征(trait)，开发人员就能轻松的研发跨平台的应用。

## OAM 价值

### 云原生化

OAM 应用定义是声明式的，即面向终态的。

它的格式与 Kubernetes 一致，可以与 Kubernetes 的 CRD 无缝对接。
实际在 Kubernetes 平台的实现就是 CRD。

OAM 应用定义是自包含的。
通过 OAM 定义的描述可以找到包含一个应用生命周期中的所有信息。

![image](https://70data.oss-cn-beijing.aliyuncs.com/note/20201218020751.png)

### 架构能力的抽象

用户的诉求其实是应用的架构，而不是具体使用哪种基础设施资源。

OAM 通过 `workloadType` 来解决这个诉求。
通过描述一个应用的 `workloadType` 来定义应用的架构。

可以是简单的无状态应用，表示应用可复制、可访问、并作为守护进程长久运行。
也可以是一个有状态、有数据的复杂应用。

![image](https://70data.oss-cn-beijing.aliyuncs.com/note/20201123173932.jpg)

使用 OAM 应用定义让用户真正关心的是架构，而不是具体的基础设施。

### 从基础设施层面

基础设施，指的是像 Kubernetes 这类的提供基础服务能力与抽象的一层服务体系。

Kubernetes 提供了许多种类的基础服务和强大的扩展能力来灵活扩展其他基础服务。

云原生的普及很大程度上推动了基础设施即代码的实现。
Kubernetes 作为一个基础设施平台，通过声明式 API，让用户习惯了通过 YAML 文件描述需要的资源，这其实就是基础设施即代码的实现。

Kubernetes 存在一个问题：缺乏统一的机制来注册和管理自定义扩展能力。
这些扩展能力的表达方式不够统一，有些是 CRD、有些是 annotation、有些是 confagmap，虽然都是 YAML。

OAM 提供了抽象来统一定义和管理这些能力。
有了 OAM，各平台实现就有了基于统一标准规范来抹平差异化的能力。

**ToB 场景非常有意义**

### 从应用运维者层面

应用运维，指的是给应用加上网络接入、复杂均衡、弹性伸缩等运维操作。

运维的一个痛点就是原来这些能力并不是跨平台的。
这导致在不同平台、不同环境下去部署和运维应用的操作，是不互通和不兼容的。

**ToB 场景尤为严重**

OAM 通过一套标准定义，让不同的平台也能通过统一的方式管理，实现调和。

如下图所示，一个应用包含两部分组件，一个 web 服务和一个数据库。

数据库组件需要具有数据备份的能力。
web 服务组件需要具备可以被访问、弹性扩缩容。

这些能力由 OAM 的解释器统一管理，从此运维能力绑定出现冲突也不再是烦恼。

### 从应用开发者层面

应用开发，指的就是业务逻辑开发，这是业务产生价值的核心位置。

希望应用开发者能够专注于业务开发，而不需要关心运维细节。

Kubernetes 提供的 API，并没有很好地分离开发和运维的关注点，即使在上层抽象了平台。

OAM 分离了开发和运维的关注点，很好地解决了以上问题，让整个发布流程更加连贯、高效。

![image](https://70data.oss-cn-beijing.aliyuncs.com/note/20201123173832.jpg)

### 弹性可扩展

OAM 应用定义是弹性、可扩展的。

OAM 将原先 Kubernetes All-in-one 的复杂 API 做了一定层次的解耦。
分为应用研发(Component)，应用运维(Component)，组合并绑定 trait 变成 AppConfig，以及基础设施提供方(提供 OAM 的解释能力映射到实际的基础设施团队或厂商)。

不同角色分工协作，从而整体简化单个角色关注的内容。
使不同角色可以更聚焦、更专业的做好本角色的工作。

提供了模块化协作的能力。
大大提高了复用能力。

![image](https://70data.oss-cn-beijing.aliyuncs.com/note/20201123174048.jpg)

### 透明化的集成

开发、测试、生产环境高度一致。

## OAM 场景

实际上，几乎所有基于 Kubernetes 的应用管理平台都对通过 OAM 来以标准化的方式去构建自己的应用模型有明确的诉求。

另一方面，由于 OAM 是原生的 Kubernetes API 资源模型，这里的迁移过程难度很低，可以通过 API 对象灰度纳管的方式逐步完成迁移操作。

相比于传统 PaaS 封闭的、不能同`以 Operator 为基础的云原生生态`衔接的现状，基于 OAM 和 Kubernetes 构建的现代云原生应用管理平台，本质上是一个`以应用为中心`的 Kubernetes，保证了这个应用平台在能够无缝接入整个云原生生态。

OAM 可以进一步屏蔽掉容器基础设施的复杂性和差异性，为平台的使用者带来低心智负担的、标准化的、一致的应用管理与交付体验。

基于 OAM 构建的 Kubernetes 应用平台：
1. 能够隐藏底层基础设施的细节，专注于应用层抽象，提供以应用为中心的资源模型。
2. OAM 划分了应用交付路径上的开发、运维、基础架构三种角色，分离了关注点，让流程更加清晰和易于管理。
3. OAM 站在 Kubernetes API 资源模型的肩膀之上，提供了可移植的应用与基础设施抽象，让一个应用描述可以完全不加修改的在云、边、端等任何环境下直接交付运行起来。

![image](https://70data.oss-cn-beijing.aliyuncs.com/note/20201218020937.png)

![image](https://70data.oss-cn-beijing.aliyuncs.com/note/20201123175210.png)

## Demo

OAM 的 Kubernetes 实现：
https://github.com/oam-dev/rudr

https://github.com/harmonycloud/oam-simple-demo

# KubeVela

KubeVela 本身是一个易于使用的工具，能够以最小的工作量描述应用程序并将其发布到 Kubernetes。
但是，KubeVela 会引入一个额外的语言，也就是 CUELang。

KubeVela 相当于是基于 OAM 的高配版 Docker Compose。

对于平台开发人员来说，KubeVela 是一个框架。

## 特性(其实和 OAM 一样)

- 以应用为中心。在 Appfile 的后面，KubeVela 定义了一个应用程序概念。
- 本地扩展。KubeVela 中的应用程序由各种可插拔工作负载类型和操作功能(traits)组成。
- 简单但可扩展的抽象机制。KubeVela 的主要用户界面(Appfile、CLI)，将面向用户的模式转换为相应的 Kubernetes 资源。

## 组件

### 工作负载 workload

![image](https://70data.oss-cn-beijing.aliyuncs.com/note/20201123180038.png)

核心 KubeVela API 是基于开放应用程序模型(OAM)构建的。
因此，workloadType 和 trait 概念是从 OAM 继承的。

一个 workloadType 声明运行时基础设施应该考虑到应用管理特性。
参考 OAM 部分。

### 能力 capability

capability 是运行时基础结构提供的功能，可以支持应用程序管理要求。

### 服务 service

service 是 KubeVela 中最小可部署单元的描述符。

service 代表在 Kubernetes 中运行应用程序所需的运行时配置。

### 应用 application

KubeVela 中的 application 是 service 的集合。

application 描述了从更高层次定义的构建和发布的内容。

application 由 KubeVela 中的 Appfile(vela.yaml 默认命名)定义。

### 环境 environment

在 KubeVela 中，environment 为各种部署环境。

每个 environment 都有其自己的配置。

## Demo

```
name: first-vela-app
services:
  testsvc:
    type: webservice
    image: crccheck/hello-world
    port: 8000
    route:
      domain: testsvc.example.com
```

```
# vela up -f vela.yaml
Parsing vela.yaml ...
Loading templates ...
Rendering configs for service (testsvc)...
Writing deploy config to (.vela/deploy.yaml)
Applying deploy configs ...
Checking if app has been deployed...
App has not been deployed, creating a new deployment...
✅ App has been deployed 🚀🚀🚀
    Port forward: vela port-forward first-vela-app
             SSH: vela exec first-vela-app
         Logging: vela logs first-vela-app
      App status: vela status first-vela-app
  Service status: vela status first-vela-app --svc testsvc
```

```
# vela status first-vela-app
About:
  Name:       first-vela-app
  Namespace:  default
  Created at: ...
  Updated at: ...
Services:
  - Name: testsvc
    Type: webservice
    HEALTHY Ready: 1/1
    Last Deployment:
      Created at: ...
      Updated at: ...
    Routes:
      - route: Visiting URL: http://testsvc.example.com IP: localhost
```

# 总结

- OAM 是面向平台架构师的
- OAM runtime 是面向平台工程师的
- KubeVela 是面向终端用户的
