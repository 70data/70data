---
title: Linux 网络发送数据包流程
date: 2020-12-02
tags: 
---

### 协议栈

##### socket

1. `socket`。

创建一个 socket 结构体，并初始化相应的操作函数。

2. `sendto`。

应用层的程调用该函数开始发送数据包，该函数数会调用后面的 `inet_sendmsg`。

3. `inet_sendmsg`。

检查当前 socket 有没有绑定源端口，如果没有的话，调用 `inet_autobind` 分配一个。

4. `inet_autobind`。

调用 socket 上绑定的 `get_port` 函数获取一个可用的端口。

<!--more-->

##### UDP 层

1. `udp_sendmsg`。

UDP 模块发送数据包的入口。

调用 `ip_route_output_flow` 获取路由信息，主要包括源 IP 和网卡。
调用 `ip_make_skb` 构造 skb 结构体。
将网卡的信息和 skb 关联。

2. `ip_route_output_flow`。

根据路由表和目的 IP，找到这个数据包应该从哪个设备发送出去。

如果该 socket 没有绑定源 IP，还会根据路由表找到一个最合适的源 IP 给它。
如果该 socket 已经绑定了源 IP，但根据路由表，从这个源 IP 对应的网卡没法到达目的地址，则该包会被丢弃，于是数据发送失败，`sendto` 函数将返回错误。

最后会将找到的设备和源 IP 塞进 flowi4 结构体并返回给 `udp_sendmsg`。

3. `ip_make_skb`。

构造 skb：
- MTU
- UDP corking 如果启用
- UDP Fragmentation Offloading(UFO)，如果硬件不支持 UFO，但是要传输的数据大于 MTU，需要软件做分片
- Fragmentation(分片)

构造好的 skb 里面已经分配了 IP 包头，并且初始化了部分信息。IP 包头的源 IP 就在这里被设置进去。

调用 `__ip_append_dat`，如果需要分片的话，会在 `__ip_append_data` 函数中进行分片。

检查 socket 的 send buffer 是否已经用光，如果被用光的话，返回 ENOBUFS。

4. `udp_send_skb`。

- 向 skb 添加 UDP 头
- 处理校验和 checksum，软件校验和，硬件校验和或无校验和
- 调用 `ip_send_skb` 将 skb 发送到 IP 协议层
- 更新发送成功或失败的统计计数器

##### IP 层

1. `ip_send_skb`。

IP 模块发送数据包的入口。
只是简单的调用一下后面的函数。

2. `ip_local_out` & `__ip_local_out`

`ip_local_out` 只需调用 `__ip_local_out`，如果返回值为 1，则调用路由层 `dst_output` 发送数据包。

3. `__ip_local_out_sk`。

设置 IP 报文头的长度和 checksum，然后调用 netfilter 的钩子。

4. `NF_INET_LOCAL_OUT`。

netfilter 的钩子，可以通过 iptables 来配置怎么处理该数据包。

如果该数据包没被丢弃，则继续往下走。

5. `dst_output_sk`。

根据 skb 里面的信息，调用相应的 output 函数。
IPv4 这种情况下，会调用 `ip_output`。

6. `ip_output`。

将 `udp_sendmsg` 得到的网卡信息写入 skb，然后调用 `NF_INET_POST_ROUTING` 的钩子。

7. `NF_INET_POST_ROUTING`。

有可能配置了 SNAT，从而导致该 skb 的路由信息发生变化。

8. `ip_finish_output`。

判断经过了上一步后，路由信息是否发生变化。
如果发生变化的话，需要重新调用 `dst_output_sk`，否则往下走。

重新调用 `dst_output_sk` 时，可能就不会再走到 `ip_output`，而是走到被 netfilter 指定的 output 函数里，这里有可能是 `xfrm4_transport_output`。

9. `ip_finish_output2`。

根据目的 IP 到路由表里面找到下一跳 nexthop 的地址。
调用 `__ipv4_neigh_lookup_noref` 去 arp 表里面找下一跳的 neigh 信息。
没找到的话会调用 `__neigh_create` 构造一个空的 neigh 结构体。

将包发送到邻居缓存之前处理各种统计计数器。

10. `dst_neigh_output`。

将 neigh 信息里面的 MAC 地址填到 skb 中，然后调用 `dev_queue_xmit` 发送数据包。

如果上一步 `ip_finish_output2` 没得到 neigh 信息，那么将会走到函数 `neigh_resolve_output` 中，否则直接调用 `neigh_hh_output`。

11. `neigh_resolve_output`。

发送 arp 请求，得到下一跳的 MAC 地址。
将 MAC 地址填到 skb 中并调用 `dev_queue_xmit`。

### netdevice 子系统

1. `dev_queue_xmit` & `__dev_queue_xmit`

`dev_queue_xmit` 简单封装了 `__dev_queue_xmit`

netdevice 子系统的入口函数。

获取设备对应的 qdisc，如果没有的话，就直接调用 `dev_hard_start_xmit`，否则数据包将经过 Traffic Control 模块进行处理。

2. `dev_hard_start_xmit`。

如果 `dev_hard_start_xmit` 返回错误的话(大部分情况可能是 `NETDEV_TX_BUSY`)，调用它的函数会把 skb 放到一个地方，然后抛出软中断 `NET_TX_SOFTIRQ`，交给软中断处理程序 `net_tx_action` 稍后重试。

拷贝一份 skb 给 taps。tcpdump 就是从这里得到数据的。

调用 `ndo_start_xmit`。

3. Traffic Control。

进行过滤和优先级处理。

如果队列满了的话，数据包会被丢掉。

4. `ndo_start_xmit`。

### 网络设备驱动

1. `ndo_start_xmit`。

`ndo_start_xmit` 会绑定到具体网卡驱动的相应函数。
由网卡驱动接管，不同的网卡驱动有不同的处理方式。

- `ndo_start_xmit` 发送数据
- `ndo_get_stats64` 获取统计信息
- `ndo_do_ioctl` ioctls 处理设备

2. 将 skb 放入网卡自己的发送队列 `tx ring buffer`。

```
# 查看网卡 TX Queue 数量
ethtool -l eth0
```

不是所有设备驱动都支持这个选项。
如果的网卡不支持，会报错。

```
ethtool -l eth0
Channel parameters for eth0: Cannot get device channel parameters, Operation not supported
```

```
# 调整网卡 TX queue 数量
ethtool -L eth0 combined 8
```

一些设备及其驱动只支持 combined queue，这种情况下一个 TX queue 和和一个 RX queue 绑定到一起的。
如果设备和驱动支持分别设置 TX queue 和 RX queue 的数量，那可以分别设置。

```
ethtool -L eth0 tx 8
```

```
# 查看队列当前的大小
ethtool -g eth0
调整 TX queue 大小
ethtool -G eth0 tx 4096
```

3. 通知网卡发送数据包。

4. 网卡发送完成后发送中断给 CPU。

5. 收到中断后进行 skb 的清理工作。

在网卡驱动发送数据包过程中，会有一些地方需要和 netdevice 子系统打交道。
比如网卡的队列满了，需要告诉上层不要再发了，等队列有空闲的时候，再通知上层接着发数据。

![image](https://70data.oss-cn-beijing.aliyuncs.com/note/20201128233503.png)
