<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 千夜同学</title>
    <link>http://70data.net/tags/Go.html</link>
    <description>Recent content in Go on 千夜同学</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 31 May 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://70data.net/tags/Go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go cond 锁定期唤醒锁</title>
      <link>http://70data.net/archives/2017-05-31.html</link>
      <pubDate>Wed, 31 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://70data.net/archives/2017-05-31.html</guid>
      <description>package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; &amp;quot;time&amp;quot; ) var</description>
    </item>
    
    <item>
      <title>Go 中如何阻塞等待所有 goroutines 都完成</title>
      <link>http://70data.net/archives/2017-05-30.html</link>
      <pubDate>Tue, 30 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://70data.net/archives/2017-05-30.html</guid>
      <description>&lt;p&gt;方案一：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;runtime&amp;quot;
    &amp;quot;sync&amp;quot;
    &amp;quot;time&amp;quot;
)

// 定义一个同步等待的组
var wg sync.WaitGroup

// 定义一个Printer函数用于并发
func Printer(a int) {
    time.Sleep(2000 * time.Millisecond)
    fmt.Printf(&amp;quot;i am %d\n&amp;quot;, a)
    defer wg.Done()
}

func main() {
    // 获取cpu个数
    maxProcs := runtime.NumCPU()
    // 限制同时运行的goroutines数量
    runtime.GOMAXPROCS(maxProcs)
    for i := 0; i &amp;lt; 10; i++ {
        //为同步等待组增加一个成员
        wg.Add(1)
        //并发一个goroutine
        go Printer(i)
    }
    // 阻塞等待所有组内成员都执行完毕退栈
    wg.Wait()
    fmt.Println(&amp;quot;WE DONE!!!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>